from pymetasploit3.msfrpc import MsfRpcClient
import time
class MsfWrapper(object):
    def __init__(self, targets_report_file_name):
        #Connects to the msf rpc client
        self.client = MsfRpcClient("supersecret")
       
        #Gets available msf console
        self.client_console = self._get_available_client_console()
        
        #Checks if msf console status is connected, if not connects and loads report results.
        self._intialize_database(targets_report_file_name)
       
        #Checks if initalisation is successful        
        data = self.get_command_response("hosts")
        print(data)

    def get_command_response(self, command_to_send):  
        """
        Sends client's message and awaits/returns for the response
        """  
        data = ''

        self._wait_until_console_not_busy()
        self.client_console.write(command_to_send) 
        self._wait_until_console_not_busy()
        client_response = self.client_console.read()
        self._wait_until_console_not_busy() #TODO remove
        data = client_response['data']
                
        return data

    def get_module_options(self, module):
        module_options = self.get_command_response("use " + module)
        module_options = self.get_command_response("show options")
        #print (module_options) 
        return module_options

    def search_msf_modules(self, search_term):
        self._wait_until_console_not_busy()
        response = self.get_command_response("search " + search_term)
        return response

    def get_client(self):
        if self.client is not None:
            return self.client

    def _get_available_client_console(self):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = self.client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = self.client.consoles.console().cid
        return self.client.consoles.console(console_id)

    def _intialize_database(self, report_file_name):
        """
        Checks wether client is connected to a database.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (not self._check_client_db_connected()):
            self.get_command_response("db_connect")
            #self.client_console.write("db_connect")
        import_command = "db_import "+report_file_name
        response = self.get_command_response(import_command)
        print(response)

    def _check_client_db_connected(self):
        """
        Checks if the client is connected to database
        """
        #self.client_console.write("db_status")     
        #client_db_status = self.client_console.read()
        self._wait_until_console_not_busy()
        client_db_status = self.get_command_response("db_status")
        database_not_connected = "no connection" in client_db_status
        if(self.client_console.is_busy() or database_not_connected):
            return False
        return True

    def _wait_until_console_not_busy(self):
        console_busy = True
        while console_busy:
            time.sleep(0.1)
            console_busy = self.client_console.is_busy()