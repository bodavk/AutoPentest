from pymetasploit3.msfrpc import MsfRpcClient
import subprocess
import time

class MetasploitManager(object):
    def set_targets(self, targets_report_file_name):
        """
        Sets up the environment so that the msf can be used properly.
        """
        #TODO mount the volume on autopentest docker image and run this script in there
        #self._start_and_initialize_required_services()
        
        #Connects to the msf rpc client
        self.client = MsfRpcClient("supersecret")
       
        #Gets available msf console
        self.client_console = self._get_available_client_console(self.client)
        
        #Checks if msf console status is connected, if not connects and loads report results.
        self._intialize_database(self.client_console, targets_report_file_name)
       
        #Checks if initalisation is successful        
        data = self._get_command_response(self.client_console, "hosts")
        print(data)
        pass

    def exploit(self, output_report_filename):
        self._overwrite_report_file(output_report_filename)
        self.report = ''

        scanner_modules = self._get_nonbruteforce_auxiliary_modules("scanner", self.client) #TODO maybe remove "the aux type
        detected_services = self._get_services(self.client_console)
        final_module_list = self._filter_modules_by_services(scanner_modules,detected_services,"scanner",self.client_console)
        #filtered_scanner_modules = self._filter_modules_by_service_name(scanner_modules, detected_services)
        #final_modules = self._filter_modules_by_service_info(self.client_console, detected_services, filtered_scanner_modules, "scanner")
        self._try_modules(final_module_list, output_report_filename) 


        #Region Exploiting
        # TODO use this mechanism for exploit instead of using it for aux modules.
        # Implement aux scanning only with a few scanners that actually output something (http crawler for example)
        # Exploiting phase is similiar but it needs to choose a payload for the exploit (different try method maybe)  
        # Select the module, check if the target is vulnerable to the exploit (check module command)    
        # if it is, select proper payload (meterpreter most likely) -> add size check, if payload doesn't fit skip it
        # 
        #Endregion 
        pass

    def _start_and_initialize_required_services(self):
        """
        Starts postgress service if it wasn't started already on host,
        initializes msfdb and starts msfrpcd on the host
        """
        try:
            subprocess.run(["service", "postgresql", "start"])
            subprocess.run(["msfdb", "init"])
            subprocess.run(["msfrpcd", "-P", "supersecret", "-S"])
        except Exception as identifier:
            print(identifier)

    def _get_available_client_console(self, client):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = client.consoles.console().cid
        return client.consoles.console(console_id)

    def _intialize_database(self, msf_client, report_file_name):
        """
        Checks wether client is connected to a database.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (not self._check_client_db_connected(msf_client)):
            msf_client.write("db_connect")
        import_command = "db_import /home/"+report_file_name
        response = self._get_command_response(msf_client, import_command)
        print(response)

    def _check_client_db_connected(self, client_console):
        """
        Checks if the client is connected to database
        """
        client_console.write("db_status")     
        client_db_status = client_console.read()
        client_busy = client_db_status['busy']
        database_not_connected = "no connection" in client_db_status['data']
        if(client_busy or database_not_connected):
            return False
        return True

    def _get_command_response(self, client_console, command_to_send):  
        """
        Sends client's message and awaits/returns for the response
        """  
        data = ''
        client_console.write(command_to_send) 
        console_busy = True
        while(console_busy):
            time.sleep(0.5)
            console_busy = client_console.is_busy()
            if (not console_busy):
                client_response = client_console.read()
                data = client_response['data']
        return data

    def _get_nonbruteforce_auxiliary_modules(self, desired_module_type, client):
        """
        Returns a dictionary of non-bruteforce modules of desired type (scanner/admin etc..) and their descriptions
        """
        aux_modules = client.modules.auxiliary
        final_modules = {}
        for module in aux_modules:
            if (desired_module_type in module):
                try:
                    module_info = self._get_module_description(module, client)
                    if ("bruteforc" not in module_info and "brute forc" not in module_info): #Filter out some bruteforce modules
                        final_modules[module] = module_info
                except Exception as identifier:
                    print(identifier)
        return final_modules

    def _get_module_description(self, module, client):
        temporary_module = client.modules.use("auxiliary", module)
        module_info = temporary_module.description
        return module_info

    def _get_services(self, client_console):       
        console_response = self._get_console_services(client_console)
        return self._parse_services_response(console_response)
        
    def _get_console_services(self,client_console):
        command = "services -R"
        response = self._get_command_response(client_console, command)
        print(response)
        return response

    def _parse_services_response(self, console_response):
        services = {}
        rows = console_response.splitlines()
        for row in rows[5:]:
            if ('RHOSTS' not in row and row != ''):
                collumns = row.split()
                name = collumns[3]
                if (name != '' and name not in services):
                    if (len(collumns) >= 6):
                        service_information = ' '.join(str(x) for x in collumns[5:]) 
                        services[name] = service_information 
                    else:
                        services[name] = ''
        return services

    def _filter_modules_by_services(self, modules, services, desired_module_type, client_console):
        filtered_scanner_modules = self._filter_modules_by_service_name(modules, services)
        return self._filter_modules_by_service_info(services, filtered_scanner_modules, desired_module_type, client_console)

    def _filter_modules_by_service_name(self, modules, services):
        final_modules = []
        for module_key in modules.keys(): 
            for service_key in services.keys(): 
                if (service_key in module_key and service_key in modules[module_key]): #if service name is in module 
                    final_modules.append(module_key)
        return final_modules

    def _filter_modules_by_service_info(self, services, list_of_possible_modules, desired_module_type, client_console):
        module_list = set()
        for service_key in services.keys():
            if(services[service_key] != ''):
                response = self._get_command_response(client_console, "search "+services[service_key])
                response_modules = self._parse_search_response(response, desired_module_type)
                module_list.update(response_modules)    
        possbile_modules = set(list_of_possible_modules)
        result_list = possbile_modules.intersection(module_list)
        return result_list

    def _parse_search_response(self, response, module_type):
        module_names = []
        if (response != ''):
            rows = response.splitlines()
            for row in rows[6:(len(rows)-2)]:
                columns = row.split()
                if (len(columns)>2 and columns[1] != '' and columns[1] not in module_names and module_type in columns[1]):
                    module_name = columns[1]
                    position = module_name.find(module_type) # crop the auxiliary, exploit or other module group names
                    module_names.append(module_name[position:])
        if (len(module_names)>15):
            return module_names[:10] #TODO if there are more than 10 outputs remove the rest. 
        else:
            return module_names
                    
    def _try_modules(self, module_list, output_report_filename):
        if (len(module_list)>0):
            for module in module_list:
                module_usable_without_user = self._check_module_usability(module, self.client_console)
                if (module_usable_without_user):
                    print("Currently trying to run {0} module. Please wait untill it has finished with execution".format(module))
                    response = self._get_command_response(self.client_console, "exploit")
                    self._add_to_report(module, response)
                    self._write_to_report(output_report_filename)

    def _check_module_usability(self, module, client_console):
        module_options = self._get_module_options(module,client_console)
        if (module_options != ''):
            module_option_rows = module_options.splitlines()
            module_usable = self._all_required_settings_configured(module_option_rows)
            return module_usable

    def _get_module_options(self, module, client_console):
        module_options = self._get_command_response(client_console,"use " + module)
        module_options = self._get_command_response(client_console, "show options")
        print (module_options) 
        return module_options

    def _all_required_settings_configured(self, module_options):
        for row in module_options:
                if (row != '' and row not in module_options[:5]):
                    words = row.split()
                    if (len(words) > 3 and words[1] == "yes" and words[2]!= "yes"): 
                #If the row is split by spaces/tabs and current setting is empty yes will be on index 1 instead of 2
                #That means that a required setting is not set up and module can't be used
                        return False 
        return True                    

    def _overwrite_report_file(self, output_report_filename):
        with open(output_report_filename, "w") as output_file:
            output_file.write("")

    def _add_to_report(self, module, response):
        self.report = ""
        if (response != ""):
            self.report += "MODULE USED> "+module+"\n"
            self.report += "Begin response\n\n"
            self.report += response
            self.report += "End response \n\n"          
        print("Module "+module+" done with execution. Results added to the report.")

    def _write_to_report(self, output_report_filename):
        """
        Writes an output based on success of exploatation phase of the penetration test
        """
        if (self.report != ''):
            with open(output_report_filename, "a") as output_file:
                output_file.write(self.report)
            print("MSF action report was written to the: " + output_report_filename)
        else:
            print("Nothing from this action was added to the report file")

    
#TODO -> Information gathering / recon option for faster run time of a program
# TODO check this list of aux scanner modules 
# https://www.offensive-security.com/metasploit-unleashed/auxiliary-module-reference/ 
#
# SMB version scanning  -> https://www.offensive-security.com/metasploit-unleashed/port-scanning/
# -> https://www.offensive-security.com/metasploit-unleashed/smb-login-check/
# (if port 445 open)
#
# SQL https://www.offensive-security.com/metasploit-unleashed/hunting-mssql/
# 
# SSH https://www.offensive-security.com/metasploit-unleashed/service-identification/
# (if port 22 open)
#
# FTP (same url as above) 
# (if port 21 open)
# 
# VNC https://www.offensive-security.com/metasploit-unleashed/vnc-authentication/
#
#
# 
# TODO Additional information gathering to be implemented:
# SNMP maybe https://www.offensive-security.com/metasploit-unleashed/snmp-scan/
# WMAP maybe https://www.offensive-security.com/metasploit-unleashed/wmap-web-scanner/
# NeXPose maybe https://www.offensive-security.com/metasploit-unleashed/nexpose-msfconsole/
# https://www.offensive-security.com/metasploit-unleashed/working-with-nexpose/ 
# *the link above shows how to start the scan and use it to create xml report, import into msf
# and use in addition to msf vulns 
# Nessus maybe https://www.offensive-security.com/metasploit-unleashed/nessus-via-msfconsole/
# https://www.offensive-security.com/metasploit-unleashed/working-with-nessus/
#* the link above shows how to import nessus scan reports
