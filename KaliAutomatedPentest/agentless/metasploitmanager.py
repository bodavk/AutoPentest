from pymetasploit3.msfrpc import MsfRpcClient
import subprocess
import time

class MetasploitManager(object):
    def set_targets(self, targets_report_file_name):
        """
        Sets up the environment so that the msf can be used properly.
        """
        #TODO mount the volume on autopentest docker image and run this script in there
        #self._start_and_initialize_required_services()
        
        #Connects to the msf rpc client
        self.client = MsfRpcClient("supersecret")
       
        #Gets available msf console
        self.client_console = self._get_available_client_console(self.client)
        
        #Checks if msf console status is connected, if not connects and loads report results.
        self._intialize_database(self.client_console, targets_report_file_name)
       
        #Checks if initalisation is successful        
        data = self._get_command_response(self.client_console, "hosts")
        print(data)
        pass

    def _start_and_initialize_required_services(self):
        """
        Starts postgress service if it wasn't started already on host,
        initializes msfdb and starts msfrpcd on the host
        """
        try:
            subprocess.run(["service", "postgresql", "start"])
            subprocess.run(["msfdb", "init"])
            subprocess.run(["msfrpcd", "-P", "supersecret", "-S"])
        except Exception as identifier:
            print(identifier)

    def _get_available_client_console(self, client):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = client.consoles.console().cid
        return client.consoles.console(console_id)

    def _intialize_database(self, msf_client, report_file_name):
        """
        Checks wether client is connected to a database.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (not self._check_client_db_connected(msf_client)):
            msf_client.write("db_connect")
        msf_client.write("db_import /home/agentless/"+report_file_name)
        print(msf_client.read())

    def _check_client_db_connected(self, client_console):
        """
        Checks if the client is connected to database
        """
        client_console.write("db_status")     
        client_db_status = client_console.read()
        client_busy = client_db_status['busy']
        database_not_connected = "no connection" in client_db_status['data']
        if(client_busy or database_not_connected):
            return False
        return True

    def _get_command_response(self, client_console, command_to_send):  
        """
        Sends client's message and awaits/returns for the response
        """  
        data = ''
        client_console.write(command_to_send) 
        console_busy = client_console.is_busy()
        while(console_busy):
            time.sleep(0.5)
            console_busy = client_console.is_busy()
            if (not console_busy):
                client_response = client_console.read()
                data = client_response['data']
        return data


    def exploit(self):
        command = "services -R"
        #TODO -> Information gathering / recon 
        # TODO check this list of aux scanner modules 
        # https://www.offensive-security.com/metasploit-unleashed/auxiliary-module-reference/ 
        #
        # SMB version scanning  -> https://www.offensive-security.com/metasploit-unleashed/port-scanning/
        # -> https://www.offensive-security.com/metasploit-unleashed/smb-login-check/
        # (if port 445 open)
        #
        # SQL https://www.offensive-security.com/metasploit-unleashed/hunting-mssql/
        # 
        # SSH https://www.offensive-security.com/metasploit-unleashed/service-identification/
        # (if port 22 open)
        #
        # FTP (same url as above) 
        # (if port 21 open)
        # 
        # VNC https://www.offensive-security.com/metasploit-unleashed/vnc-authentication/
        #
        #
        # 
        # TODO Additional information gathering to be implemented:
        # SNMP maybe https://www.offensive-security.com/metasploit-unleashed/snmp-scan/
        # WMAP maybe https://www.offensive-security.com/metasploit-unleashed/wmap-web-scanner/
        # NeXPose maybe https://www.offensive-security.com/metasploit-unleashed/nexpose-msfconsole/
        # https://www.offensive-security.com/metasploit-unleashed/working-with-nexpose/ 
        # *the link above shows how to start the scan and use it to create xml report, import into msf
        # and use in addition to msf vulns 
        # Nessus maybe https://www.offensive-security.com/metasploit-unleashed/nessus-via-msfconsole/
        # https://www.offensive-security.com/metasploit-unleashed/working-with-nessus/
        #* the link above shows how to import nessus scan reports

        response = self._get_command_response(self.client_console, command)
        print(response)

        #TODO other option is to load a list of all aux modules and go one by one if 
        # services list contains that service (not sure what to search for though -> maybe name column -c name)
        # -c host port name
        # extract list of names
        # go through all aux modules and try to find all aux modules of that service name
        # run it with the -R option and start them, wait for response
        aux_modules = self.client.modules.auxiliary

        #If exploits are successful export everything to an xml file
        pass

    def generate_report(self):
        """
        Writes an output based on success of exploatation phase of the penetration test
        """
        self.report = "No successful exploit methods found for specified targets"
        return self.report