from pymetasploit3.msfrpc import MsfRpcClient
import subprocess

class MetasploitManager(object):
    def set_targets(self, targets):
        """
        Sets up the environment so that the msf can be used properly.
        """

        #TODO mount the volume on autopentest docker image and run this script in there
        #self._start_and_initialize_required_services()
        
        #Connect to the msf rpc client
        client = MsfRpcClient("supersecret")
       
        #Get available msf console
        self.client_console = self._get_available_client_console(client)
        
        #Checks if msf console status is connected, if not -> connects it 
        #else clear results, load new results into it       
        self._intialize_database(self.client_console)
       
        pass

    def _start_and_initialize_required_services(self):
        """
        Starts postgress service if it wasn't started already on host,
        initializes msfdb and starts msfrpcd on the host
        """
        try:
            subprocess.run(["service", "postgresql", "start"])
            subprocess.run(["msfdb", "init"])
            subprocess.run(["msfrpcd", "-P", "supersecret"])
        except Exception as identifier:
            print(identifier)

    def _get_available_client_console(self, client):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = client.consoles.console().cid
        return client.consoles.console(console_id)

    def _intialize_database(self, msf_client):
        """
        Checks wether client is connected to a database.
        If it is the db is wiped.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (self._check_client_db_connected(msf_client)):
            #TODO execute db_remove to wipe the db
            pass        
        else:
            #TODO connect to an existing db
            pass
        #TODO if client has db connection try to import report.xml -> Will possibly have to define the whole path to file
        msf_client.write("db_import report.xml")
        #print(msf_client.read())

    def _check_client_db_connected(self, client_console):
        """
        Checks if the client is connected to database
        """
        client_console.write("db_status")     
        client_db_status = client_console.read()
        #TODO implement logic
        client_busy = client_db_status['busy']
        database_not_connected = "no connection" in client_db_status['data']
        if(client_busy or database_not_connected):
            return False
        return True


    def exploit(self):
        #TODO try to exploit the target here
        #Use info from the report to attack the target if possible
        #If attack is successful write the module and settings down
        #Write down the unsucessfull tries
        pass

    def generate_report(self):
        """
        Writes an output based on success of exploatation phase of the penetration test
        """
        self.report = "No successful exploit methods found for specified targets"
        return self.report