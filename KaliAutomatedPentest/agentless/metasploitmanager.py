from pymetasploit3.msfrpc import MsfRpcClient
import subprocess
import time

class MetasploitManager(object):
    def set_targets(self, targets_report_file_name):
        """
        Sets up the environment so that the msf can be used properly.
        """
        #TODO mount the volume on autopentest docker image and run this script in there
        #self._start_and_initialize_required_services()
        
        #Connects to the msf rpc client
        self.client = MsfRpcClient("supersecret")
       
        #Gets available msf console
        self.client_console = self._get_available_client_console(self.client)
        
        #Checks if msf console status is connected, if not connects and loads report results.
        self._intialize_database(self.client_console, targets_report_file_name)
       
        #Checks if initalisation is successful        
        data = self._get_command_response(self.client_console, "hosts")
        print(data)
        pass

    def exploit(self, output_report_filename):
        self._overwrite_report_file(output_report_filename)
        self.report = ''
        scanner_modules = self._get_modules("admin", self.client, self.client_console)
        detected_services = self._get_service_types(self.client_console)       
        chosen_scanner_modules = self._filter_modules(scanner_modules, detected_services)
        self._try_modules(chosen_scanner_modules, output_report_filename)       
        pass

    def _start_and_initialize_required_services(self):
        """
        Starts postgress service if it wasn't started already on host,
        initializes msfdb and starts msfrpcd on the host
        """
        try:
            subprocess.run(["service", "postgresql", "start"])
            subprocess.run(["msfdb", "init"])
            subprocess.run(["msfrpcd", "-P", "supersecret", "-S"])
        except Exception as identifier:
            print(identifier)

    def _get_available_client_console(self, client):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = client.consoles.console().cid
        return client.consoles.console(console_id)

    def _intialize_database(self, msf_client, report_file_name):
        """
        Checks wether client is connected to a database.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (not self._check_client_db_connected(msf_client)):
            msf_client.write("db_connect")
        import_command = "db_import /home/"+report_file_name
        response = self._get_command_response(msf_client, import_command)
        print(response)

    def _check_client_db_connected(self, client_console):
        """
        Checks if the client is connected to database
        """
        client_console.write("db_status")     
        client_db_status = client_console.read()
        client_busy = client_db_status['busy']
        database_not_connected = "no connection" in client_db_status['data']
        if(client_busy or database_not_connected):
            return False
        return True

    def _get_command_response(self, client_console, command_to_send):  
        """
        Sends client's message and awaits/returns for the response
        """  
        data = ''
        client_console.write(command_to_send) 
        console_busy = True
        while(console_busy):
            time.sleep(0.5)
            console_busy = client_console.is_busy()
            if (not console_busy):
                client_response = client_console.read()
                data = client_response['data']
        return data

    def _get_modules(self, module_type, client, client_console):     
        aux_modules = client.modules.auxiliary
        final_modules = []
        for module in aux_modules:
            if (module_type in module):
                final_modules.append(module)
        return final_modules

    def _get_service_types(self, client_console):
        command = "services -R"
        response = self._get_command_response(client_console, command)
        print(response)
        services = []
        rows = response.splitlines()
        for row in rows:
            if (row not in rows [:5] and 'RHOSTS' not in row and row != ''):
                collumns = row.split()
                name = collumns[3]
                if (name != '' and name not in services):
                    services.append(name) #TODO check if ports or info are useful to save as well (maybe as a dictionary)
        pass
        return services

    def _filter_modules(self, modules, services):
        final_modules = []
        for module in modules:
            for service in services:
                if (service in module): #Check if service port is for that module somehow? // if it's login don't just append it
                    final_modules.append(module)
        return final_modules

    def _check_module_usability(self, module, client_console):
        module_options = self._get_module_options(module,client_console)
        if (module_options != ''):
            module_option_rows = module_options.splitlines()
            module_usable = self._all_required_settings_configured(module_option_rows)
            return module_usable

    def _get_module_options(self, module, client_console):
        module_options = self._get_command_response(client_console,"use " + module)
        module_options = self._get_command_response(client_console, "show options")
        print (module_options) 
        return module_options

    def _all_required_settings_configured(self, module_options):
        for row in module_options:
                if (row != '' and row not in module_options[:5]):
                    words = row.split()
                    if (len(words) > 3 and words[1] == "yes" and words[2]!= "yes"): 
                #If the row is split by spaces/tabs and current setting is empty yes will be on index 1 instead of 2
                #That means that a required setting is not set up and module can't be used
                        return False 
        return True

    def _try_modules(self, module_list, output_report_filename):
        if (len(module_list)>0):
            for module in module_list:
                module_usable_without_user = self._check_module_usability(module, self.client_console)
                if (module_usable_without_user):
                    print("Currently trying to run {0} module. Please wait untill it has finished with execution".format(module))
                    response = self._get_command_response(self.client_console, "exploit")
                    self._add_to_report(module, response)
                    self._write_to_report(output_report_filename)

    def _overwrite_report_file(self, output_report_filename):
        with open(output_report_filename, "w") as output_file:
            output_file.write("")

    def _add_to_report(self, module, response):
        self.report = ""
        if (response != ""):
            self.report += "MODULE USED> "+module+"\n"
            self.report += "Begin response\n\n"
            self.report += response
            self.report += "End response \n\n"          
        print("Module "+module+" done with execution. Results added to the report.")

    def _write_to_report(self, output_report_filename):
        """
        Writes an output based on success of exploatation phase of the penetration test
        """
        if (self.report != ''):
            with open(output_report_filename, "a") as output_file:
                output_file.write(self.report)
            print("MSF action report was written to the: " + output_report_filename)
        else:
            print("Nothing from this action was added to the report file")

    
#TODO -> Information gathering / recon option for faster run time of a program
# TODO check this list of aux scanner modules 
# https://www.offensive-security.com/metasploit-unleashed/auxiliary-module-reference/ 
#
# SMB version scanning  -> https://www.offensive-security.com/metasploit-unleashed/port-scanning/
# -> https://www.offensive-security.com/metasploit-unleashed/smb-login-check/
# (if port 445 open)
#
# SQL https://www.offensive-security.com/metasploit-unleashed/hunting-mssql/
# 
# SSH https://www.offensive-security.com/metasploit-unleashed/service-identification/
# (if port 22 open)
#
# FTP (same url as above) 
# (if port 21 open)
# 
# VNC https://www.offensive-security.com/metasploit-unleashed/vnc-authentication/
#
#
# 
# TODO Additional information gathering to be implemented:
# SNMP maybe https://www.offensive-security.com/metasploit-unleashed/snmp-scan/
# WMAP maybe https://www.offensive-security.com/metasploit-unleashed/wmap-web-scanner/
# NeXPose maybe https://www.offensive-security.com/metasploit-unleashed/nexpose-msfconsole/
# https://www.offensive-security.com/metasploit-unleashed/working-with-nexpose/ 
# *the link above shows how to start the scan and use it to create xml report, import into msf
# and use in addition to msf vulns 
# Nessus maybe https://www.offensive-security.com/metasploit-unleashed/nessus-via-msfconsole/
# https://www.offensive-security.com/metasploit-unleashed/working-with-nessus/
#* the link above shows how to import nessus scan reports
