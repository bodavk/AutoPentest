from pymetasploit3.msfrpc import MsfRpcClient
import subprocess

class MetasploitManager(object):
    def set_targets(self, targets_report_file_name):
        """
        Sets up the environment so that the msf can be used properly.
        """
        #TODO mount the volume on autopentest docker image and run this script in there
        #self._start_and_initialize_required_services()
        
        #Connects to the msf rpc client
        client = MsfRpcClient("supersecret")
       
        #Gets available msf console
        self.client_console = self._get_available_client_console(client)
        
        #Clears the buffer of msf ascii art
        print(self.client_console.read())
        
        #Checks if msf console status is connected, if not connects and loads report results.
        self._intialize_database(self.client_console, targets_report_file_name)
       
        self.client_console.write("hosts")
        print(self.client_console.read())
        pass

    def _start_and_initialize_required_services(self):
        """
        Starts postgress service if it wasn't started already on host,
        initializes msfdb and starts msfrpcd on the host
        """
        try:
            subprocess.run(["service", "postgresql", "start"])
            subprocess.run(["msfdb", "init"])
            subprocess.run(["msfrpcd", "-P", "supersecret", "-S"])
        except Exception as identifier:
            print(identifier)

    def _get_available_client_console(self, client):
        """
            Returns first available console id if there are consoles created, otherwise creates new console and returns it's id
        """
        list_of_consoles = client.consoles.list
        if(len(list_of_consoles)>0):
            last_element = list_of_consoles[-1]
            console_id = last_element['id']
        else:
            console_id = client.consoles.console().cid
        return client.consoles.console(console_id)

    def _intialize_database(self, msf_client, report_file_name):
        """
        Checks wether client is connected to a database.
        If connection doesn't exist, the client is connected to the postgresql database.
        Nmap scan results are imported.
        """
        if (not self._check_client_db_connected(msf_client)):
            msf_client.write("db_connect")
        msf_client.write("db_import /home/agentless/"+report_file_name)
        print(msf_client.read())

    def _check_client_db_connected(self, client_console):
        """
        Checks if the client is connected to database
        """
        client_console.write("db_status")     
        client_db_status = client_console.read()
        client_busy = client_db_status['busy']
        database_not_connected = "no connection" in client_db_status['data']
        if(client_busy or database_not_connected):
            return False
        return True


    def exploit(self):
        #TODO try to exploit the target here
        #Use info from the report to attack the target if possible
        #If attack is successful write the module and settings down
        #Write down the unsucessfull tries
        pass

    def generate_report(self):
        """
        Writes an output based on success of exploatation phase of the penetration test
        """
        self.report = "No successful exploit methods found for specified targets"
        return self.report